// PromptForm.js
import { useState, useEffect } from 'react';
import { exportConfigAsYaml } from '../utils/exportConfig';
import Tooltip from './Tooltip';
import { tooltipDefinitions } from '../utils/tooltipDefinitions';
import AdvancedOptimizationParams from './AdvancedOptimizationParams';
import AdvancedEvaluationMetrics from './AdvancedEvaluationMetrics';
import DatasetPreview from './DatasetPreview';
import MultimodalSupport from './MultimodalSupport';
import SessionManagement from './SessionManagement';
import TabContainer from './TabContainer';

const PromptForm = ({ setOptimizedPrompt, optimizedPrompt }) => {
  const [formData, setFormData] = useState({
    taskDescription: '',
    baseInstruction: '',
    answerFormat: '',
    model: 'Gemini',
    apiKey: '',
    dataset: 'Custom',
    customDataset: null,
    mutationRounds: 3,
    refineSteps: 2,
    mutateRefineIterations: 3,
    refineTaskEgIterations: 3,
    refineInstruction: true,
    minCorrectCount: 3,
    maxEvalBatches: 6,
    topN: 1,
    questionsBatchSize: 1,
    useExamples: false,
    generateSyntheticExamples: false,
    generateExpertIdentity: true,
    generateIntentKeywords: false,
    styleVariation: 5,
    fewShotCount: 5,
    evaluationCriteria: [],
    advancedEvaluationMetrics: [],
    showDatasetPreview: false,
    enableMultimodal: false,
    saveSession: false,
    sessionName: '',
  });

  const [isLoading, setIsLoading] = useState(false);
  const [isValidatingKey, setIsValidatingKey] = useState(false);
  const [error, setError] = useState('');
  const [customDatasetName, setCustomDatasetName] = useState('');
  const [apiStatus, setApiStatus] = useState({ checked: false, available: false });
  const [lastApiCheckTime, setLastApiCheckTime] = useState(0);
  const [apiKeyStatus, setApiKeyStatus] = useState({
    checked: false,
    valid: false,
    message: ''
  });

  const handleChange = (e) => {
    const { id, value, type, checked } = e.target;

    // Create a copy of the current form data
    const updatedFormData = { ...formData };

    // Update the field that changed
    updatedFormData[id] = type === 'checkbox' ? checked : value;

    // Handle field dependencies based on the three scenarios:
    // Scenario 1: No training data, no in-context examples (useExamples=false, generateSyntheticExamples=false)
    // Scenario 2: No training data, with in-context examples using synthetic examples (useExamples=true, generateSyntheticExamples=true)
    // Scenario 3: With training data, with in-context examples (useExamples=true, generateSyntheticExamples=false)

    if (id === 'generateSyntheticExamples') {
      if (checked) {
        // Scenario 2: If Generate Synthetic Examples is checked:
        // 1. Automatically enable Use In-Context Examples since synthetic examples are used as in-context examples
        updatedFormData.useExamples = true;
        // 2. No dataset is required since synthetic examples are generated by the LLM
      }
      // If unchecked, we don't change useExamples as the user might want Scenario 3
    }

    if (id === 'useExamples') {
      if (!checked) {
        // Scenario 1: If Use In-Context Examples is unchecked:
        // 1. Automatically uncheck Generate Synthetic Examples since synthetic examples are only used as in-context examples
        updatedFormData.generateSyntheticExamples = false;
      }
      // If checked, we don't change generateSyntheticExamples as the user might want either Scenario 2 or 3
    }

    // If dataset is changed to something other than Custom, clear customDataset
    if (id === 'dataset' && value !== 'Custom') {
      updatedFormData.customDataset = null;
      setCustomDatasetName('');
    }

    // Update the form data
    setFormData(updatedFormData);
  };

  // Check if the API is available
  const checkApiHealth = async () => {
    try {
      // Update the last check time
      setLastApiCheckTime(Date.now());

      // Try the default API path first
      let response = await fetch('/api/health');

      if (response.ok) {
        const data = await response.json();
        setApiStatus({ checked: true, available: data.success });
        return true;
      }

      // If that fails, try direct connection to port 5000
      try {
        console.log('Trying direct connection to port 5000...');
        response = await fetch('http://localhost:5000/api/health');

        if (response.ok) {
          const data = await response.json();
          setApiStatus({ checked: true, available: data.success });
          console.log('Connected directly to port 5000');
          return true;
        }
      } catch (directErr) {
        console.log('Failed to connect directly to port 5000');
      }

      // If that fails too, try port 5001
      try {
        console.log('Trying direct connection to port 5001...');
        response = await fetch('http://localhost:5001/api/health');

        if (response.ok) {
          const data = await response.json();
          setApiStatus({ checked: true, available: data.success });
          console.log('Connected directly to port 5001');
          return true;
        }
      } catch (directErr) {
        console.log('Failed to connect directly to port 5001');
      }

      // If all attempts fail, set status to unavailable
      setApiStatus({ checked: true, available: false });
      return false;
    } catch (err) {
      console.error('API health check failed:', err);
      setApiStatus({ checked: true, available: false });
      return false;
    }
  };

  // Validate the API key - optimized to avoid unnecessary API health checks
  const validateApiKey = async () => {
    if (!formData.apiKey) {
      setApiKeyStatus({
        checked: true,
        valid: false,
        message: 'Please enter an API key'
      });
      return false;
    }

    setIsValidatingKey(true);
    setError('');

    try {
      // Only check API health if we haven't checked recently or if the last check failed
      if (!apiStatus.checked || !apiStatus.available || Date.now() - lastApiCheckTime > 30000) {
        const isApiAvailable = await checkApiHealth();
        if (!isApiAvailable) {
          setApiKeyStatus({
            checked: true,
            valid: false,
            message: 'API server is not available'
          });
          return false;
        }
      } else if (!apiStatus.available) {
        // If we already know the API is unavailable, don't try to validate
        setApiKeyStatus({
          checked: true,
          valid: false,
          message: 'API server is not available'
        });
        return false;
      }

      // Send validation request
      const response = await fetch('/api/validate_key', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          apiKey: formData.apiKey,
          model: formData.model
        }),
      });

      const data = await response.json();

      setApiKeyStatus({
        checked: true,
        valid: data.valid,
        message: data.message
      });

      return data.valid;
    } catch (err) {
      console.error('API key validation failed:', err);
      setApiKeyStatus({
        checked: true,
        valid: false,
        message: err.message || 'Failed to validate API key'
      });
      return false;
    } finally {
      setIsValidatingKey(false);
    }
  };

  // Check API health when component mounts
  useEffect(() => {
    checkApiHealth();
  }, []);

  const handleFileUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      setCustomDatasetName(file.name);

      // Read the file
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          // Try to parse as JSON
          const jsonData = JSON.parse(event.target.result);
          setFormData(prev => ({
            ...prev,
            customDataset: jsonData
          }));
          setError('');
        } catch (err) {
          console.error('Error parsing file:', err);
          setError('Invalid file format. Please upload a valid JSON file.');
          setFormData(prev => ({
            ...prev,
            customDataset: null
          }));
          setCustomDatasetName('');
        }
      };
      reader.readAsText(file);
    }
  };

  const handleEvaluationCriteriaChange = (e) => {
    const { value, checked } = e.target;
    setFormData({
      ...formData,
      evaluationCriteria: checked
        ? [...formData.evaluationCriteria, value]
        : formData.evaluationCriteria.filter(criteria => criteria !== value)
    });
  };

  const handleAdvancedMetricsChange = (e) => {
    const { value, checked } = e.target;
    setFormData({
      ...formData,
      advancedEvaluationMetrics: checked
        ? [...formData.advancedEvaluationMetrics, value]
        : formData.advancedEvaluationMetrics.filter(metric => metric !== value)
    });
  };

  // Effect to update the checked state of evaluation criteria checkboxes when evaluationCriteria changes
  useEffect(() => {
    // This will ensure the checkboxes reflect the current state of evaluationCriteria
    // Especially important when setting evaluationCriteria programmatically
  }, [formData.evaluationCriteria]);

  // Validate form data - optimized for speed
  const validateForm = () => {
    // Fast path: Check required fields directly without array iteration
    if (!formData.taskDescription) {
      return { valid: false, message: 'Task Description is required' };
    }

    if (!formData.baseInstruction) {
      return { valid: false, message: 'Base Instruction is required' };
    }

    if (!formData.apiKey) {
      return { valid: false, message: 'API Key is required' };
    }

    // Check numeric fields
    if (!formData.mutationRounds || formData.mutationRounds < 1) {
      return { valid: false, message: 'Mutation Rounds must be at least 1' };
    }

    if (!formData.refineSteps || formData.refineSteps < 1) {
      return { valid: false, message: 'Refine Steps must be at least 1' };
    }

    // Check dependencies based on the three scenarios:
    // Scenario 1: No training data, no in-context examples (useExamples=false, generateSyntheticExamples=false)
    // Scenario 2: No training data, with in-context examples using synthetic examples (useExamples=true, generateSyntheticExamples=true)
    // Scenario 3: With training data, with in-context examples (useExamples=true, generateSyntheticExamples=false)

    if (formData.useExamples) {
      // If using in-context examples...

      if (!formData.generateSyntheticExamples) {
        // Scenario 3: Using real examples from dataset
        // Dataset is required and must be valid
        if (formData.dataset === 'Custom' && !formData.customDataset) {
          return { valid: false, message: 'Custom dataset is required when using in-context examples without synthetic examples' };
        }
      }
      // Scenario 2: Using synthetic examples
      // Dataset is optional and can be used for evaluation
    }

    // Validate that generateSyntheticExamples requires useExamples
    if (formData.generateSyntheticExamples && !formData.useExamples) {
      return { valid: false, message: 'Use In-Context Examples must be enabled when generating synthetic examples' };
    }

    return { valid: true };
  };

  const handleOptimizePrompt = async (e) => {
    e.preventDefault();

    // Validate form fields first (this is fast and synchronous)
    const validation = validateForm();
    if (!validation.valid) {
      setError(validation.message);
      return;
    }

    setIsLoading(true);
    setError('');

    try {
      // Only check API health if we haven't checked recently or if the last check failed
      // This avoids unnecessary network requests
      if (!apiStatus.checked || !apiStatus.available || Date.now() - lastApiCheckTime > 30000) {
        const isApiAvailable = await checkApiHealth();
        if (!isApiAvailable) {
          throw new Error('API server is not available. Please make sure the backend is running.');
        }
      }

      // Only validate API key if it hasn't been validated yet or if it was invalid
      // This avoids unnecessary network requests
      if (!apiKeyStatus.checked || !apiKeyStatus.valid) {
        const isKeyValid = await validateApiKey();
        if (!isKeyValid) {
          throw new Error(`Invalid API key: ${apiKeyStatus.message}`);
        }
      }

      // Prepare data for API
      const apiData = {
        taskDescription: formData.taskDescription,
        baseInstruction: formData.baseInstruction,
        answerFormat: formData.answerFormat,
        model: formData.model,
        mutationRounds: formData.mutationRounds,
        refineSteps: formData.refineSteps,
        mutateRefineIterations: formData.mutateRefineIterations,
        refineTaskEgIterations: formData.refineTaskEgIterations,
        refineInstruction: formData.refineInstruction,
        minCorrectCount: formData.minCorrectCount,
        maxEvalBatches: formData.maxEvalBatches,
        topN: formData.topN,
        questionsBatchSize: formData.questionsBatchSize,
        useExamples: formData.useExamples,
        generateSyntheticExamples: formData.generateSyntheticExamples,
        generateExpertIdentity: formData.generateExpertIdentity,
        generateIntentKeywords: formData.generateIntentKeywords,
        styleVariation: formData.styleVariation,
        fewShotCount: formData.fewShotCount,
        dataset: formData.dataset,
        evaluationCriteria: formData.evaluationCriteria,
        advancedEvaluationMetrics: formData.advancedEvaluationMetrics,
        enableMultimodal: formData.enableMultimodal,
        saveSession: formData.saveSession,
        sessionName: formData.sessionName,
        apiKey: formData.apiKey
      };

      // Add custom dataset if available
      if (formData.dataset === 'Custom' && formData.customDataset) {
        apiData.customDataset = formData.customDataset;
      }

      console.log('Sending data to API:', apiData);

      // Always use the relative URL path which will be handled by Next.js rewrites
      const apiUrl = '/api/optimize_prompt';

      console.log('Sending request to API at:', apiUrl);

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(apiData),
      });

      // Check if response is ok before trying to parse JSON
      if (!response.ok) {
        // Try to parse as JSON first
        let errorMessage = `API responded with status: ${response.status}`;
        try {
          const errorData = await response.json();
          if (errorData && errorData.error) {
            errorMessage = errorData.error;
          }
        } catch (jsonError) {
          // If JSON parsing fails, try to get text content
          try {
            const textContent = await response.text();
            if (textContent && textContent.length < 100) {
              errorMessage = textContent;
            }
          } catch (textError) {
            console.error('Failed to parse error response as text:', textError);
          }
        }
        throw new Error(errorMessage);
      }

      // Now we know the response is OK, parse the JSON
      let data;
      try {
        data = await response.json();
      } catch (jsonError) {
        throw new Error('Invalid JSON response from server');
      }

      if (data.success) {
        setOptimizedPrompt(data.optimizedPrompt);
      } else {
        throw new Error(data.error || 'Unknown error occurred');
      }
    } catch (err) {
      console.error('Error optimizing prompt:', err);

      // Provide more helpful error message
      let errorMessage = `Failed to optimize prompt: ${err.message}`;
      if (err.message === 'Failed to fetch') {
        errorMessage = 'Failed to connect to the API server. Please make sure the backend is running and try again.';
      }
      setError(errorMessage);

      // Always use mock response for demo purposes when there's an error
      const mockResponse = {
        optimizedPrompt: `[MOCK RESPONSE] Optimized prompt for: "${formData.taskDescription}"\n\n${formData.baseInstruction}\n\nAdditional instructions: Please ensure all responses follow the format: ${formData.answerFormat}\n\nThis prompt has been optimized using ${formData.mutationRounds} mutation rounds and ${formData.refineSteps} refine steps.\n\n(Note: This is a mock response because the API server could not be reached.)`
      };

      // Only show the mock response if the user confirms
      if (window.confirm('API server error. Would you like to see a mock response instead?')) {
        setOptimizedPrompt(mockResponse.optimizedPrompt);
      }
    } finally {
      setIsLoading(false);
    }
  };

  // Function to fill test values
  const fillTestValues = () => {
    setFormData({
      ...formData,
      taskDescription: "write image description to give to any image gen model",
      baseInstruction: "cute and young punjabi couples taking fere, ghibli style",
      refineSteps: 4,
      mutateRefineIterations: 3,
      refineTaskEgIterations: 3,
      refineInstruction: true,
      minCorrectCount: 3,
      maxEvalBatches: 6,
      topN: 1,
      questionsBatchSize: 1,
      useExamples: true, // Enable this since generateSyntheticExamples requires it
      generateSyntheticExamples: true, // With synthetic examples, we don't need a dataset
      generateExpertIdentity: true,
      generateIntentKeywords: true,
      styleVariation: 3,
      evaluationCriteria: ["Clarity", "Completeness", "Relevance"],
      advancedEvaluationMetrics: ["Faithfulness", "SemanticSimilarity"],
      enableMultimodal: true,
      // Keep the dataset as is, but it will be disabled in the UI when synthetic examples are enabled
    });

    // Clear any custom dataset since we're using synthetic examples
    if (formData.dataset === 'Custom') {
      setCustomDatasetName('');
    }
  };

  // Define tab content components
  const renderBasicInfoTab = () => (
    <div className="flex flex-wrap -mx-3 mb-6">
      <div className="w-full px-3 mb-6">
        <label className="block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2" htmlFor="taskDescription">
          <Tooltip text={tooltipDefinitions.taskDescription}>
            Task Description: <span className="text-red-500">*</span>
          </Tooltip>
        </label>
        <textarea
          className="appearance-none block w-full bg-gray-200 text-gray-700 border border-gray-200 rounded py-3 px-4 leading-tight focus:outline-none focus:bg-white focus:border-gray-500"
          id="taskDescription"
          rows="3"
          value={formData.taskDescription}
          onChange={handleChange}
          placeholder="Describe the task you want to optimize a prompt for"
          required
        />
      </div>

      <div className="w-full px-3 mb-6">
        <label className="block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2" htmlFor="baseInstruction">
          <Tooltip text={tooltipDefinitions.baseInstruction}>
            Base Instruction: <span className="text-red-500">*</span>
          </Tooltip>
        </label>
        <textarea
          className="appearance-none block w-full bg-gray-200 text-gray-700 border border-gray-200 rounded py-3 px-4 leading-tight focus:outline-none focus:bg-white focus:border-gray-500"
          id="baseInstruction"
          rows="5"
          value={formData.baseInstruction}
          onChange={handleChange}
          placeholder="Enter your initial prompt that needs optimization"
          required
        />
      </div>

      <div className="w-full md:w-1/2 px-3 mb-6">
        <label className="block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2" htmlFor="answerFormat">
          <Tooltip text={tooltipDefinitions.answerFormat}>
            Answer Format:
          </Tooltip>
        </label>
        <input
          className="appearance-none block w-full bg-gray-200 text-gray-700 border border-gray-200 rounded py-3 px-4 leading-tight focus:outline-none focus:bg-white focus:border-gray-500"
          id="answerFormat"
          type="text"
          value={formData.answerFormat}
          onChange={handleChange}
          placeholder="Specify the desired output format"
        />
      </div>

      <div className="w-full md:w-1/2 px-3 mb-6">
        <label className="block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2" htmlFor="model">
          <Tooltip text={tooltipDefinitions.model.label}>
            Model: <span className="text-red-500">*</span>
          </Tooltip>
        </label>
        <select
          className="appearance-none block w-full bg-gray-200 text-gray-700 border border-gray-200 rounded py-3 px-4 leading-tight focus:outline-none focus:bg-white focus:border-gray-500"
          id="model"
          value={formData.model}
          onChange={handleChange}
        >
          <option value="Gemini">Gemini</option>
          <option value="GPT-4">GPT-4</option>
          <option value="Custom">Custom</option>
        </select>
        {formData.model === 'Custom' && (
          <p className="text-xs italic mt-1 text-gray-600">
            Custom model: You'll need to provide an API key and ensure the backend is configured to use your custom model.
          </p>
        )}
      </div>

      <div className="w-full px-3 mb-6">
        <label className="block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2" htmlFor="apiKey">
          <Tooltip text={tooltipDefinitions.apiKey}>
            API Key: <span className="text-red-500">*</span>
          </Tooltip>
        </label>
        <div className="flex">
          <input
            className="appearance-none block w-full bg-gray-200 text-gray-700 border border-gray-200 rounded-l py-3 px-4 leading-tight focus:outline-none focus:bg-white focus:border-gray-500"
            id="apiKey"
            type="password"
            value={formData.apiKey}
            onChange={(e) => {
              handleChange(e);
              // Reset API key status when key changes
              setApiKeyStatus({
                checked: false,
                valid: false,
                message: ''
              });
            }}
            placeholder="Enter your API key"
          />
          <button
            type="button"
            className={`px-4 py-2 text-white rounded-r focus:outline-none ${
              isValidatingKey
                ? 'bg-gray-400 cursor-wait'
                : apiKeyStatus.checked && apiKeyStatus.valid
                  ? 'bg-green-500 hover:bg-green-600'
                  : 'bg-blue-500 hover:bg-blue-600'
            }`}
            onClick={validateApiKey}
            disabled={isValidatingKey || !formData.apiKey}
          >
            {isValidatingKey
              ? 'Validating...'
              : apiKeyStatus.checked && apiKeyStatus.valid
                ? 'âœ“ Valid'
                : 'Validate'}
          </button>
        </div>
        {apiKeyStatus.checked && (
          <p className={`mt-1 text-xs ${apiKeyStatus.valid ? 'text-green-600' : 'text-red-600'}`}>
            {apiKeyStatus.message}
          </p>
        )}
      </div>
    </div>
  );

  const renderDataSelectionTab = () => (
    <div className="flex flex-wrap -mx-3 mb-6">
      <div className="w-full px-3 mb-6">
        <label className="block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2" htmlFor="dataset">
          <Tooltip text={tooltipDefinitions.dataset.label}>
            Dataset:
            {formData.useExamples && !formData.generateSyntheticExamples && (
              <span className="text-red-500">*</span>
            )}
            {formData.generateSyntheticExamples && (
              <span className="ml-2 text-xs text-blue-600">(optional for evaluation)</span>
            )}
          </Tooltip>
        </label>
        <select
          className="appearance-none block w-full bg-gray-200 text-gray-700 border border-gray-200 rounded py-3 px-4 leading-tight focus:outline-none focus:bg-white focus:border-gray-500"
          id="dataset"
          value={formData.dataset}
          onChange={handleChange}
        >
          <option value="Custom">Custom</option>
          <option value="GSM8k">GSM8k (Math Problem Solving)</option>
          <option value="SVAMP">SVAMP (Basic Arithmetic)</option>
          <option value="AQUARAT">AQUARAT (Algebraic Reasoning)</option>
          <option value="BBII">BBII (Instruction Following)</option>
        </select>
        {formData.dataset === 'Custom' && (
          <div className="mt-2">
            <p className="text-xs italic mb-2 text-gray-600">
              Custom dataset: Upload a JSON file with your training examples or optimize without a dataset.
            </p>

            <div className="flex items-center">
              <label className="flex items-center justify-center px-4 py-2 bg-blue-100 text-blue-700 rounded cursor-pointer hover:bg-blue-200">
                <span className="text-sm font-medium">Upload Dataset</span>
                <input
                  type="file"
                  className="hidden"
                  accept=".json"
                  onChange={handleFileUpload}
                />
              </label>

              {customDatasetName && (
                <span className="ml-3 text-sm text-gray-600">
                  {customDatasetName}
                </span>
              )}
            </div>

            <div className="mt-2 text-xs text-gray-500">
              <p>Expected format: JSON array of objects with "input" and "output" fields.</p>
              <p>Example: [{'{'}input: "question", output: "answer"{'}'}], ...</p>
            </div>
          </div>
        )}
        {formData.generateSyntheticExamples && (
          <div className="mt-2">
            <p className="text-xs italic text-blue-600">
              Synthetic examples will be generated for training. Dataset can still be used for evaluation.
            </p>
          </div>
        )}
      </div>

      <div className="w-full md:w-1/3 px-3 mb-6 flex items-center">
        <label className="flex items-center">
          <input
            type="checkbox"
            id="useExamples"
            checked={formData.useExamples}
            onChange={handleChange}
            className="mr-2"
          />
          <Tooltip text={tooltipDefinitions.useExamples}>
            <span className="text-gray-700">Use In-Context Examples</span>
          </Tooltip>
        </label>
      </div>

      <div className="w-full md:w-1/3 px-3 mb-6 flex items-center">
        <label className="flex items-center">
          <input
            type="checkbox"
            id="generateSyntheticExamples"
            checked={formData.generateSyntheticExamples}
            onChange={handleChange}
            className="mr-2"
            disabled={!formData.useExamples}
          />
          <Tooltip text={tooltipDefinitions.generateSyntheticExamples}>
            <span className={`${!formData.useExamples ? 'text-gray-400' : 'text-gray-700'}`}>
              Generate Synthetic Examples
              {!formData.useExamples && (
                <span className="ml-2 text-xs text-orange-500">(requires Use In-Context Examples)</span>
              )}
            </span>
          </Tooltip>
        </label>
      </div>

      <div className="w-full md:w-1/3 px-3 mb-6">
        <label className="block text-sm font-bold mb-1" htmlFor="fewShotCount">
          <Tooltip text={tooltipDefinitions.fewShotCount}>
            <span className={`${!formData.useExamples ? 'text-gray-400' : 'text-gray-700'}`}>
              Few Shot Count:
              {!formData.useExamples && (
                <span className="ml-2 text-xs text-orange-500">(requires Use In-Context Examples)</span>
              )}
            </span>
          </Tooltip>
        </label>
        <input
          className={`appearance-none block w-full border rounded py-2 px-3 leading-tight focus:outline-none ${
            !formData.useExamples
              ? 'bg-gray-100 text-gray-400 border-gray-200 cursor-not-allowed'
              : 'bg-white text-gray-700 border-gray-300 focus:border-blue-500'
          }`}
          id="fewShotCount"
          type="number"
          min="0"
          max="10"
          value={formData.fewShotCount}
          onChange={handleChange}
          disabled={!formData.useExamples}
        />
      </div>

      {/* Dataset Preview (if dataset is available) */}
      {formData.dataset === 'Custom' && formData.customDataset && (
        <div className="w-full px-3 mb-6">
          <div className="flex items-center mb-2">
            <label className="flex items-center">
              <input
                type="checkbox"
                id="showDatasetPreview"
                checked={formData.showDatasetPreview}
                onChange={handleChange}
                className="mr-2"
              />
              <Tooltip text={tooltipDefinitions.showDatasetPreview}>
                <span className="text-gray-700 font-semibold">Show Dataset Preview</span>
              </Tooltip>
            </label>
          </div>
          {formData.showDatasetPreview && (
            <DatasetPreview dataset={formData.customDataset} />
          )}
        </div>
      )}
    </div>
  );

  const renderPromptConfigTab = () => (
    <div className="flex flex-wrap -mx-3 mb-6">
      {/* Scenario Selection Section */}
      <div className="w-full px-3 mb-6">
        <div className="border border-gray-200 rounded p-4 bg-gray-50">
          <div className="flex justify-between items-center mb-3">
            <h3 className="text-lg font-semibold">Scenario Selection</h3>
            <div className="flex space-x-2">
              <button
                type="button"
                className="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200"
                onClick={() => {
                  // Scenario 1: No training data, no in-context examples
                  setFormData({
                    ...formData,
                    useExamples: false,
                    generateSyntheticExamples: false,
                    generateExpertIdentity: true,
                    generateIntentKeywords: true,
                    mutationRounds: 5
                  });
                }}
              >
                <Tooltip text="No training data, no in-context examples in final prompt">
                  Scenario 1
                </Tooltip>
              </button>
              <button
                type="button"
                className="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200"
                onClick={() => {
                  // Scenario 2: No training data, with in-context examples (synthetic)
                  setFormData({
                    ...formData,
                    useExamples: true,
                    generateSyntheticExamples: true,
                    generateExpertIdentity: true,
                    generateIntentKeywords: false,
                    mutationRounds: 2,
                    fewShotCount: 5
                  });
                }}
              >
                <Tooltip text="No training data, with in-context examples in final prompt (using synthetic examples). Dataset optional for evaluation.">
                  Scenario 2
                </Tooltip>
              </button>
              <button
                type="button"
                className="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200"
                onClick={() => {
                  // Scenario 3: With training data, with in-context examples
                  setFormData({
                    ...formData,
                    useExamples: true,
                    generateSyntheticExamples: false,
                    generateExpertIdentity: true,
                    generateIntentKeywords: false,
                    mutationRounds: 2,
                    fewShotCount: 5
                  });
                }}
              >
                <Tooltip text="With training data and with in-context examples in final prompt">
                  Scenario 3
                </Tooltip>
              </button>
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {/* Generate Expert Identity */}
            <div className="flex items-center">
              <label className="flex items-center">
                <input
                  type="checkbox"
                  id="generateExpertIdentity"
                  checked={formData.generateExpertIdentity}
                  onChange={handleChange}
                  className="mr-2"
                />
                <Tooltip text={tooltipDefinitions.generateExpertIdentity}>
                  <span className="text-gray-700">Generate Expert Identity</span>
                </Tooltip>
              </label>
            </div>

            {/* Generate Intent Keywords */}
            <div className="flex items-center">
              <label className="flex items-center">
                <input
                  type="checkbox"
                  id="generateIntentKeywords"
                  checked={formData.generateIntentKeywords}
                  onChange={handleChange}
                  className="mr-2"
                />
                <Tooltip text={tooltipDefinitions.generateIntentKeywords}>
                  <span className="text-gray-700">Generate Intent Keywords</span>
                </Tooltip>
              </label>
            </div>

            {/* Style Variation */}
            <div>
              <label className="block text-gray-700 text-sm font-bold mb-1" htmlFor="styleVariation">
                <Tooltip text={tooltipDefinitions.styleVariation}>
                  Style Variation: <span className="text-xs text-blue-500">(recommended: 3-5)</span>
                </Tooltip>
              </label>
              <div className="relative">
                <input
                  className="appearance-none block w-full bg-white text-gray-700 border border-gray-300 rounded py-2 px-3 leading-tight focus:outline-none focus:border-blue-500"
                  id="styleVariation"
                  type="number"
                  min="1"
                  max="10"
                  value={formData.styleVariation}
                  onChange={handleChange}
                />
                <div className="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
                  <span className="text-xs text-gray-500">{formData.styleVariation > 5 ? 'Higher values = more diverse but slower' : ''}</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div className="w-full md:w-1/2 px-3 mb-6">
        <label className="block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2" htmlFor="mutationRounds">
          <Tooltip text={tooltipDefinitions.mutationRounds}>
            Mutation Rounds: <span className="text-red-500">*</span>
          </Tooltip>
        </label>
        <input
          className="appearance-none block w-full bg-gray-200 text-gray-700 border border-gray-200 rounded py-3 px-4 leading-tight focus:outline-none focus:bg-white focus:border-gray-500"
          id="mutationRounds"
          type="number"
          min="1"
          max="10"
          value={formData.mutationRounds}
          onChange={handleChange}
        />
      </div>

      <div className="w-full md:w-1/2 px-3 mb-6">
        <label className="block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2" htmlFor="refineSteps">
          <Tooltip text={tooltipDefinitions.refineSteps}>
            Refine Steps: <span className="text-red-500">*</span>
          </Tooltip>
        </label>
        <input
          className="appearance-none block w-full bg-gray-200 text-gray-700 border border-gray-200 rounded py-3 px-4 leading-tight focus:outline-none focus:bg-white focus:border-gray-500"
          id="refineSteps"
          type="number"
          min="1"
          max="10"
          value={formData.refineSteps}
          onChange={handleChange}
        />
      </div>

      {/* Advanced Optimization Parameters */}
      <div className="w-full px-3 mb-6">
        <AdvancedOptimizationParams
          formData={formData}
          handleChange={handleChange}
          tooltipDefinitions={tooltipDefinitions}
        />
      </div>

      {/* Multimodal Support */}
      <div className="w-full px-3 mb-6">
        <MultimodalSupport
          formData={formData}
          handleChange={handleChange}
          tooltipDefinitions={tooltipDefinitions}
        />
      </div>
    </div>
  );

  const renderEvaluationTab = () => (
    <div className="flex flex-wrap -mx-3 mb-6">
      <div className="w-full px-3 mb-6">
        <label className="block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2">
          <Tooltip text={tooltipDefinitions.evaluationCriteria.label}>
            Basic Evaluation Criteria:
          </Tooltip>
        </label>
        <div className="flex flex-wrap">
          {['Accuracy', 'Clarity', 'Completeness', 'Relevance', 'Conciseness'].map(criteria => (
            <label key={criteria} className="inline-flex items-center mr-6 mb-2">
              <input
                type="checkbox"
                value={criteria}
                checked={formData.evaluationCriteria.includes(criteria)}
                onChange={handleEvaluationCriteriaChange}
                className="mr-2"
              />
              <Tooltip text={tooltipDefinitions.evaluationCriteria.options[criteria]}>
                <span className="text-gray-700">{criteria}</span>
              </Tooltip>
            </label>
          ))}
        </div>
      </div>

      {/* Advanced Evaluation Metrics */}
      <div className="w-full px-3 mb-6">
        <AdvancedEvaluationMetrics
          formData={formData}
          handleAdvancedMetricsChange={handleAdvancedMetricsChange}
          tooltipDefinitions={tooltipDefinitions}
        />
      </div>

      {/* Session Management */}
      <div className="w-full px-3 mb-6">
        <SessionManagement
          formData={formData}
          handleChange={handleChange}
          tooltipDefinitions={tooltipDefinitions}
        />
      </div>
    </div>
  );

  // Define the tabs for the TabContainer
  const tabs = [
    {
      label: "Basic Info",
      content: renderBasicInfoTab()
    },
    {
      label: "Data Selection",
      content: renderDataSelectionTab()
    },
    {
      label: "Prompt Configuration",
      content: renderPromptConfigTab()
    },
    {
      label: "Evaluation",
      content: renderEvaluationTab()
    }
  ];

  return (
    <form className="w-full" onSubmit={handleOptimizePrompt}>
      <div className="flex justify-between items-center mb-4 px-3">
        <div>
          <h2 className="text-xl font-bold text-gray-700">Prompt Optimization</h2>
          <p className="text-sm text-gray-500 mt-1">Fields marked with <span className="text-red-500">*</span> are required</p>
        </div>
        <button
          type="button"
          className="bg-gradient-to-r from-purple-500 to-indigo-600 hover:from-purple-600 hover:to-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50 transition-all duration-200 flex items-center"
          onClick={fillTestValues}
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z" clipRule="evenodd" />
          </svg>
          <Tooltip text="Fill form with test values for image description generation">
            <span>Test Values</span>
          </Tooltip>
        </button>
      </div>

      {error && (
        <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-4 mx-3" role="alert">
          <div className="flex items-center">
            <svg className="h-5 w-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
            <p><strong>Error:</strong> {error}</p>
          </div>
        </div>
      )}

      <div className="px-3 mb-6">
        <TabContainer tabs={tabs} />
      </div>

      <div className="flex flex-wrap -mx-3 mb-6">
        {error && (
          <div className="w-full px-3 mb-6">
            <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded relative" role="alert">
              <strong className="font-bold">Error: </strong>
              <span className="block sm:inline">{error}</span>
              <p className="text-xs mt-1">
                Please check that the backend server is running and your API key is valid.
              </p>
            </div>
          </div>
        )}

        <div className="w-full px-3 mb-2">
          <div className="flex justify-between items-center border-t border-b border-gray-200 py-2 px-3 bg-gray-50 rounded">
            <div className="flex items-center">
              <span className="text-sm font-medium mr-2">Server Status:</span>
              <span className={`inline-block w-3 h-3 rounded-full mr-1 ${apiStatus.available ? 'bg-green-500' : 'bg-red-500'}`}></span>
              <span className="text-sm">{apiStatus.available ? 'Online' : 'Offline'}</span>
            </div>

            <div className="flex items-center">
              <span className="text-sm font-medium mr-2">API Key:</span>
              <span className={`inline-block w-3 h-3 rounded-full mr-1 ${
                !apiKeyStatus.checked
                  ? 'bg-gray-300'
                  : apiKeyStatus.valid
                    ? 'bg-green-500'
                    : 'bg-red-500'
              }`}></span>
              <span className="text-sm">{
                !apiKeyStatus.checked
                  ? 'Not Validated'
                  : apiKeyStatus.valid
                    ? 'Valid'
                    : 'Invalid'
              }</span>
            </div>

            <button
              className="text-xs text-blue-500 hover:text-blue-700"
              onClick={(e) => {
                e.preventDefault();
                checkApiHealth();
              }}
            >
              Refresh Status
            </button>
          </div>
        </div>

        <div className="w-full px-3 flex justify-center space-x-4">
          <button
            className={`bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded focus:outline-none focus:shadow-outline ${
              isLoading || !apiStatus.available || (formData.apiKey && apiKeyStatus.checked && !apiKeyStatus.valid)
                ? 'opacity-50 cursor-not-allowed'
                : ''
            }`}
            type="submit"
            disabled={isLoading || !apiStatus.available || (formData.apiKey && apiKeyStatus.checked && !apiKeyStatus.valid)}
            title={
              !apiStatus.available
                ? 'API server is not available'
                : (formData.apiKey && apiKeyStatus.checked && !apiKeyStatus.valid)
                  ? 'API key is invalid'
                  : ''
            }
          >
            {isLoading ? 'Optimizing...' : 'Optimize Prompt'}
          </button>

          <button
            className="bg-gray-500 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded focus:outline-none focus:shadow-outline"
            type="button"
            onClick={() => exportConfigAsYaml(formData)}
          >
            Export Config
          </button>
        </div>
      </div>
    </form>
  );
};

export default PromptForm;
